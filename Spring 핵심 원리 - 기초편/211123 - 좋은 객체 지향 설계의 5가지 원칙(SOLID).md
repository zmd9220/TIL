# 211123 - 좋은 객체 지향 설계의 5가지 원칙(SOLID)



## SOLID 란

- 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리



### SRP 단일 책임 원칙 (Single responsibility principle)

- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 모호하다. - 실무에서 매우 애매함
  - 클 수 있고, 작을 수 있다.
  - 문맥과 상황에 따라 다르다.
- **중요한 기준은 변경**이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
- 예) UI 변경, 객체의 생성과 사용을 분리
  - 예를 들어 UI 변경을 할 때 다른 로직까지 모두 변경해야 한다면, 그것은 SRP를 잘 지키지 않은 예시
  - 또한 한 jar 파일에 view, db 접근 등 모든 로직을 관리한다면 해당 파일의 유지보수를 할 때 당사자만 제대로 된 로직을 변경할 수 있을 정도로 복잡하므로 SRP를 잘 안지킨 또 하나의 예시라고 볼 수 있다. 
- 프로젝트를 계층화 하여 관리하는 것도 SRP를 지키기 위한 하나의 노력으로 볼 수 있다.
- 책임의 범위를 적절하게 조율하는 것이 객체 지향 설계의 묘미
- 다시 한 번 정리하자면, 변경이 있을 때 한 클래스는 하나의 지점만 고치면 되는 것이 단일 책임 원칙을 잘 따르는 것이라 본다.



### OCP 개방 - 폐쇄 원칙 (Open/closed principle) - 5개 원칙 중에서도 중요한 원칙

- 소프트웨어 요소는 **확장에는 열려** 있으나 **변경에는 닫혀** 있어야 한다.
- 이런 거짓말 같은 말이? 확장을 하려면, 당연히 기존 코드를 변경?
- **다형성**을 활용해보자
  - 자동차 모델을 바꿔도 운전은 가능하다.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
  - 다형성을 이용해 기존 클래스를 상속받아 새로운 인터페이스를 만들면 기존의 클래스엔 변경이 없이 새로운 기능을 확장한 클래스를 만들 수 있다.
- 지금까지 배운 역할과 구현의 분리를 생각해보자

#### 문제점

```java 
public class MemberService {
    // 둘 중에 하나를 기능에 따라 자유롭게 가져와서 사용 가능
    // private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();
}
```

- 이제까지 살펴봤던 MemberService 클라이언트가 구현 클래스 둘 중 하나로 직접 선택해야 됨 -> 코드를 변경해야 됨
  - MemberRepository = new MemoryMemberRepository(); // 기존 코드
  - MemberRepository = new JdbcMemberRepository(); // 변경 코드
- **구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.**
- **분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.**
  - OCP가 깨진다 -> 웹앱에서 일반적으로 클라이언트가 코드를 변경해야 하는 상황
- 이 문제를 어떻게 해결해야 하나?
- 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
  - 이러한 조립, 설정자 역할을 하는 것이 스프링의 컨테이너 (DI, IoC)



### LSP 리스코프 치환 원칙 (Liskov substitution principle)

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요하다.
  - 규약을 지키지 않더라도 프로그램은 제대로 컴파일 될 것이다. 하지만 사용자 입장에서는 원래 인터페이스 상으로 원했던 기능이 나오지 않으므로 당황스러운 경험을 하게 될 것이다.
  - 엑셀 기능에서 앞으로 10km가 아닌 뒤로 10km 가라고 구현한다면, 누군가 자동차를 운전할 때 엑셀을 밟는다면 후진하는 차를 보고 매우 당황하게 될 것이고 이후에 인터페이스의 사용설명서를 믿을 수가 없게 된다.
- 단순히 컴파일에 성공하는 것을 넘어서는 이야기
- 예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함



### ISP 인터페이스 분리 원칙 (Interface segregation principle)

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확해지고, 대체 가능성이 높아진다. 
- 즉 핵심 기능을 기반으로 인터페이스를 분리 및 관리 하는 것이 좋다. (적당한 크기로 나누는 것이 중요)



### DIP 의존관계 역전 원칙 (Dependency inversion principle) - 중요한 원칙 2

- 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.
- 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻 = 클라이언트 코드가 구현 클래스를 바라보지 말고 인터페이스만 바라보라는 뜻
  - 멤버 서비스가 멤버 레포지토리만 바라봐야지 메모리 멤버 레포지토리나 Jdbc 멤버 레포지토리에 대해서는 몰라야 한다.
- 앞에서 이야기한 **역할(Role)에 의존하게 해야 한다는 것과 같다.** 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다! 구현체에 의존하게 되면 변경이 아주 어려워진다.
  - 항상 원빈은 김태희랑만 연극을 할 수 있다면 문제가 되어버림
  - 원빈이 김태희랑 하든 어떤 연극배우랑 하든 연극 자체를 할 수 있게 구성을 해야 옳은 것 
  - 연극은 대본을 기준으로 삼아야지 배우를 기준으로 삼아버리면 특정 배우간의 조합이 아니면 공연조차 할 수 없게 되어버림
- 즉 앞서서의 역할에 의존 = DIP를 한마디로 요약한 것
- 그런데 OCP에서 설명한 멤버 서비스는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.
- 앞에서 봤던 멤버 서비스 클라이언트가 구현 클래스를 직접 선택해야 하는 문제
  - MemberRepository = new **MemoryMemberRepository**();
  - 여기서 이미 멤버 서비스는 메모리 멤버 레포지토리를 알고 있다.(= 의존 한다.)
  - 즉 현 상황에서 멤버 서비스는 멤버 레포지토리 인터페이스 만이 아니라 메모리 멤버 레포지토리 구현체까지 알고 있는 상태
  - 그래서 메모리 멤버 레포지토리 부분을 다른 기능으로 변경하려고 할 때, 코드를 수정하게 되어버리는 문제가 발생하는 것
- **DIP 위반**



### 정리

- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- **다형성 만으로는 OCP, DIP를 지킬 수 없다.**
- 그렇다고 인터페이스만 알고 있다면 구현체를 언급해서 생성하지 않았기 때문에 nullpointexception 에러가 발생할 것
- 뭔가 더 필요하다.
- DIP와 OCP를 위반하지 않는 클래스를 설계하기 위한 방법은 다음 강의에서 배울 것

