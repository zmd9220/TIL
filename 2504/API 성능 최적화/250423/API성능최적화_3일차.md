# 오전



## 어제 과제 풀이 및 복습



- [addattribute](https://www.google.com/search?q=addattribute+%ED%95%98%EB%82%98%EB%A7%8C&sca_esv=cc91aa7b516a412e&ei=2SgIaJ6cGdG3vr0PzYjYGA&ved=0ahUKEwje7L2K6OyMAxXRm68BHU0EFgMQ4dUDCBA&uact=5&oq=addattribute+%ED%95%98%EB%82%98%EB%A7%8C&gs_lp=Egxnd3Mtd2l6LXNlcnAiFmFkZGF0dHJpYnV0ZSDtlZjrgpjrp4wyChAAGLADGNYEGEcyChAAGLADGNYEGEcyChAAGLADGNYEGEcyChAAGLADGNYEGEcyChAAGLADGNYEGEcyChAAGLADGNYEGEcyChAAGLADGNYEGEcyChAAGLADGNYEGEcyChAAGLADGNYEGEcyChAAGLADGNYEGEdIgAJQAFgAcAF4AZABAJgBAKABAKoBALgBA8gBAJgCAaACB5gDAIgGAZAGCpIHATGgBwCyBwC4BwA&sclient=gws-wiz-serp)

- [빈 여러개](https://www.google.com/search?q=%EB%B9%88+%EC%97%AC%EB%9F%AC%EA%B0%9C&oq=%EB%B9%88+%EC%97%AC%EB%9F%AC%EA%B0%9C&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIGCAEQRRg90gEHMzQ1ajBqOagCALACAQ&sourceid=chrome&ie=UTF-8)

- [[JPA] hibernate의 ddl-auto 속성의 종류와 주의해야할 점](https://colabear754.tistory.com/136)

- [Spring Boot SQL 보기 옵션 총 정리](https://lannstark.tistory.com/14)

- [스프링 의존성 주입이 의존성을 낮추는 이유](https://www.google.com/search?q=%EC%8A%A4%ED%94%84%EB%A7%81+%EC%9D%98%EC%A1%B4%EC%84%B1+%EC%A3%BC%EC%9E%85%EC%9D%B4+%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84+%EB%82%AE%EC%B6%94%EB%8A%94+%EC%9D%B4%EC%9C%A0&sca_esv=6a2525f9667c9ba5&ei=OCUHaI3jONOp2roPzdC7mQU&ved=0ahUKEwiN39-98OqMAxXTlFYBHU3oLlMQ4dUDCBI&uact=5&oq=%EC%8A%A4%ED%94%84%EB%A7%81+%EC%9D%98%EC%A1%B4%EC%84%B1+%EC%A3%BC%EC%9E%85%EC%9D%B4+%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84+%EB%82%AE%EC%B6%94%EB%8A%94+%EC%9D%B4%EC%9C%A0&gs_lp=Egxnd3Mtd2l6LXNlcnAiO-yKpO2UhOungSDsnZjsobTshLEg7KO87J6F7J20IOydmOyhtOyEseydhCDrgq7stpTripQg7J207JygMgUQABjvBTIFEAAY7wUyCBAAGIAEGKIEMggQABiiBBiJBTIIEAAYogQYiQVIsCtQhgxYlCpwCngAkAEDmAGkAaAB3yOqAQQwLjM3uAEDyAEA-AEBmAIcoAKEEsICChAAGLADGNYEGEfCAgUQABiABMICBBAAGB7CAgYQABgIGB7CAgYQABgFGB7CAgcQABiABBgNwgIGEAAYDRgewgIIEAAYCBgNGB7CAggQABgFGA0YHsICBRAhGKABmAMAiAYBkAYKkgcFMTAuMTigB96oAbIHBDAuMTi4B-QR&sclient=gws-wiz-serp)

- [@autowired 생성자](https://www.google.com/search?q=@autowired+%EC%83%9D%EC%84%B1%EC%9E%90&sca_esv=ad45493ffd201e24&ei=ousGaIvSOeek2roP2Z27uQ0&start=10&sa=N&sstk=Af40H4Uf-XPnFCqkGMQ6-o6qUXKSP1IHFMPbbr07i-84BG2k3mB6rTMN7ktKusCoiYEqsPFk7aWAHx9ujWr9If6CW9xGyhjjrrhukQ&ved=2ahUKEwiLq5zIueqMAxVnklYBHdnOLtcQ8tMDegQIJhAE&biw=929&bih=865&dpr=1)

- [bean 생명주기](https://dev-coco.tistory.com/170)

- https://doing7.tistory.com/11
- https://www.google.com/search?q=controller+return&oq=co&gs_lcrp=EgZjaHJvbWUqBggAEEUYOzIGCAAQRRg7MgYIARBFGDkyEwgCEC4YgwEYxwEYsQMY0QMYgAQyDQgDEAAYgwEYsQMYgAQyBggEEEUYPDIGCAUQRRg8MgYIBhBFGDwyBggHEEUYPNIBCDExNDNqMGo3qAIAsAIA&sourceid=chrome&ie=UTF-8
- https://www.google.com/search?q=%EB%A0%88%EA%B1%B0%EC%8B%9C%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90+jpa+%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0&oq=%EB%A0%88%EA%B1%B0%EC%8B%9C%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90+jpa+%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIHCAEQABjvBTIKCAIQABiABBiiBDIHCAMQABjvBTIKCAQQABiABBiiBDIKCAUQABiiBBiJBdIBCDU4MzdqMWo3qAIAsAIA&sourceid=chrome&ie=UTF-8
- [복잡한 쿼리 jpa vs mybatis](https://www.google.com/search?q=%EB%B3%B5%EC%9E%A1%ED%95%9C+%EC%BF%BC%EB%A6%AC+jpa+vs+mybatis&sca_esv=b347d5207ca6dc52&ei=bxsHaLOFLPm3vr0PrJnKIA&ved=0ahUKEwjz-JWT5-qMAxX5m68BHayMEgQQ4dUDCBI&uact=5&oq=%EB%B3%B5%EC%9E%A1%ED%95%9C+%EC%BF%BC%EB%A6%AC+jpa+vs+mybatis&gs_lp=Egxnd3Mtd2l6LXNlcnAiH-uzteyeoe2VnCDsv7zrpqwganBhIHZzIG15YmF0aXMyBRAAGO8FMggQABiABBiiBDIFEAAY7wUyBRAAGO8FSPAiUIICWJAgcAR4AJABAJgBzgGgAcYMqgEGMS4xMS4xuAEDyAEA-AEBmAIEoALjAcICChAAGLADGNYEGEfCAgQQABgemAMAiAYBkAYDkgcDMi4yoAeCDrIHAzAuMrgH3AE&sclient=gws-wiz-serp)



- 과제에서 어려웠던 점 (JS 활용이 어려웠음-각 기능 클릭마다 링크 변경하여 iframe에 적용, CSS 적용이 어려웠음)



- RESTful API 개념 재정리 (자원-resource(핵심 데이터), 행위-(get,post,put,delete))
  - URL은 명사(자원), 동작은 메소드(http)



- RestController (API 통신으로 json 데이터만 넘겨주겠다)
- Controller - 데이터



#### @controller 랑 @restconroller의 차이는 뭐야?

`@Controller`와 `@RestController`는 모두 Spring에서 컨트롤러 역할을 수행하지만, 동작 방식과 주된 용도가 약간 다릅니다. 차이를 간단히 정리하면 다음과 같습니다:

1. **기본 목적**



- `@Controller`: 주로 **뷰를 반환**하기 위해 사용됩니다. 템플릿 엔진(Thymeleaf, JSP 등)과 함께 사용되어 HTML이나 다른 뷰를 생성합니다.
- `@RestController`: **RESTful 웹 서비스**를 위한 컨트롤러로, JSON, XML 등 데이터를 반환합니다. 주로 API 서버 개발에 사용됩니다.



2. **내부 구현 차이**



- `@Controller`: 뷰 리졸버(View Resolver)를 통해 반환값을 뷰 이름으로 처리합니다. 즉, 리턴 값이 HTML이나 JSP 같은 뷰의 경로로 해석됩니다.

  

  ```java
  @Controller
  public class ViewController {
      @GetMapping("/home")
      public String home() {
          return "home"; // "home.html" 같은 뷰 이름 반환
      }
  }
  ```

  

- `@RestController`: `@Controller`에 `@ResponseBody`가 추가된 것입니다. 즉, 메서드의 반환값이 그대로 HTTP 응답 본문(body)에 작성됩니다.

  

  ```java
  @RestController
  public class RestApiController {
      @GetMapping("/api")
      public String api() {
          return "Hello, REST!"; // 본문에 "Hello, REST!" 출력
      }
  }
  ```



3. **사용 방식**



- **`@Controller`**는 뷰 템플릿을 사용하는 MVC 애플리케이션에 적합합니다.
- **`@RestController`**는 데이터(JSON/XML)만 제공하는 RESTful API 애플리케이션에 적합합니다.



요약



- **HTML 뷰 반환** → `@Controller` 사용
- **JSON/XML 반환** → `@RestController` 사용



필요한 상황에 따라 적합한 어노테이션을 선택하면 됩니다. 혹시 더 궁금한 점이 있으면 알려주세요! 



알겠습니다! 이전에 작성했던 내용을 포함해서, `XML 메시지 컨버터 설정`과 `Controller에서 XML 데이터 처리` 부분을 Markdown 형식으로 전체적으로 정리해드릴게요.

------

# Spring RESTful API에서 XML 처리 방법

스프링에서 RESTful API를 유지하면서 XML 데이터를 처리하려면 몇 가지 설정과 구현이 필요합니다.

---

## 1. XML 데이터 바인딩을 위한 라이브러리 추가
XML 데이터를 처리하려면 `Jackson`의 XML 모듈을 사용해야 합니다.
```xml
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
    <version>2.15.0</version>
</dependency>
```



------

## 2. XML 메시지 컨버터 설정

`MappingJackson2XmlHttpMessageConverter`를 사용하여 XML 데이터를 처리하도록 Spring에 메시지 컨버터를 추가합니다.

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        converters.add(new MappingJackson2XmlHttpMessageConverter());
    }
}
```

------

## 3. Controller에서 XML 데이터 처리

Spring REST 컨트롤러는 XML 데이터도 `@RequestBody`와 `@ResponseBody`를 통해 받을 수 있습니다.

```java
@RestController
@RequestMapping("/api")
public class ExampleController {
    @PostMapping(value = "/xml", consumes = MediaType.APPLICATION_XML_VALUE, produces = MediaType.APPLICATION_XML_VALUE)
    public MyXmlObject handleXmlData(@RequestBody MyXmlObject xmlObject) {
        return xmlObject;
    }
}
```

------

# @Controller와 @RestController의 차이점

Spring에서 `@Controller`와 `@RestController`의 주요 차이점은 다음과 같습니다:

| **어노테이션**    | **기능 및 목적**                                             |
| ----------------- | ------------------------------------------------------------ |
| `@Controller`     | **뷰 반환** - HTML 템플릿 엔진(Thymeleaf, JSP 등)과 함께 사용됩니다. |
| `@RestController` | **데이터 반환** - JSON/XML 데이터 반환에 적합하며 RESTful API 개발에 사용됩니다. |

------

# JSP와 Thymeleaf 템플릿 엔진의 차이점

Spring에서 서버 사이드 렌더링에 사용되는 템플릿 엔진인 JSP와 Thymeleaf의 차이점은 다음과 같습니다:

| **기준**             | **JSP**                        | **Thymeleaf**              |
| -------------------- | ------------------------------ | -------------------------- |
| **HTML 형식**        | Java 코드 포함 가능            | 순수 HTML 유지 가능        |
| **사용성**           | Java EE와 강하게 연결          | Spring과 자연스러운 통합   |
| **템플릿 처리 방식** | 런타임에서 처리                | 서버에서 미리 처리 후 반환 |
| **가독성/유지보수**  | 복잡한 코드로 어려움 발생 가능 | 깔끔한 HTML 구조 유지      |

------

# 기존 Spring 프로젝트에 Spring Boot 도입하기

Spring 레거시 프로젝트에 Spring Boot를 추가하는 단계는 다음과 같습니다:

## 주요 단계

1. **Spring Boot 의존성 추가**

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter</artifactId>
       <version>2.x.x</version>
   </dependency>
   ```

2. **메인 클래스 수정**

   ```java
   @SpringBootApplication
   public class MySpringBootApplication {
       public static void main(String[] args) {
           SpringApplication.run(MySpringBootApplication.class, args);
       }
   }
   ```

3. **설정 파일 변경** (`application.properties` 또는 `application.yml`로 변경)

   ```yaml
   server:
     port: 8080
   spring:
     datasource:
       url: jdbc:mysql://localhost:3306/mydb
       username: root
       password: secret
   ```

4. **기존 설정 점검 및 리팩토링**

   - `web.xml` 제거.
   - 기존 Bean 설정을 `@Configuration`으로 전환.

------

# `res`와 `data`의 차이 (Ajax 통신에서)

JavaScript `fetch`를 사용할 때 `res`와 `data`의 차이점은 다음과 같습니다:

| **변수** | **역할**                                        |
| -------- | ----------------------------------------------- |
| `res`    | HTTP 응답 객체(헤더, 상태코드 포함).            |
| `data`   | `res.json()`으로 변환된 JSON 데이터(본문 내용). |

------

## 코드 흐름 예제

```js
fetch("/api/persons")
    .then(res => res.json()) // JSON 객체로 변환
    .then(data => console.log(data)); // 변환된 데이터를 출력
```

------

이제 전체 내용이 Markdown 형식으로 잘 정리되었을 거예요. 복사해서 `.md` 파일에 붙여넣으시면 됩니다. 혹시 문제가 지속되거나 더 필요한 부분이 있다면 말씀해 주세요! 😊

```

```



## 성능 최적화

- CSR을 통한 서버 부하 감소(서버 경량화) - ajax
- JPA를 통한 쿼리 단순화 및 유지보수 용이 (간단한 쿼리)
- Redis - 응답속도 향상, 서버 부하 분산
- k6, JMeter - 부하 테스트 / 응답시간 분석





## RESTful API 어제에 이어서

- /api/persons/{id} 추가
- ![image-20250423103548884](API성능최적화_3일차.assets/image-20250423103548884.png)





## JPA 성능 최적화

- fetch join
- ![image-20250423112537055](API성능최적화_3일차.assets/image-20250423112537055.png)



- 외래키, join 구조 추가

- ```java
  package com.example.resttest.model;
  
  import java.util.List;
  
  import jakarta.persistence.Entity;
  import jakarta.persistence.GeneratedValue;
  import jakarta.persistence.GenerationType;
  import jakarta.persistence.Id;
  import jakarta.persistence.ManyToOne;
  import jakarta.persistence.Table;
  import lombok.AllArgsConstructor;
  import lombok.Getter;
  import lombok.NoArgsConstructor;
  import lombok.Setter;
  
  @Entity
  @Table(name="orders") // Order 테이블은 중복될 수 있어서 이름 바꿈
  @Getter
  @Setter
  @NoArgsConstructor
  @AllArgsConstructor
  public class Order {
  	// 행을 구분하는 PK 반드시 필요 (테이블 생성을 위해) 별도 구분자가 없을 경우 row 갯수 마다 자동 증가하는 ID를 키로 쓰면 됨	
  	@Id
  	@GeneratedValue(strategy = GenerationType.IDENTITY)
  	private Long id;
  	
  	private String productName;
  	private double price;
  	
  	@ManyToOne // 여러 주문은 한 사람에게 적용 될 수 있음
  	private Person person;
  }
  ```

- ```java
  package com.example.resttest.model;
  
  import java.util.ArrayList;
  import java.util.List;
  
  import jakarta.persistence.Entity;
  import jakarta.persistence.GeneratedValue;
  import jakarta.persistence.GenerationType;
  import jakarta.persistence.Id;
  import jakarta.persistence.OneToMany;
  import lombok.AllArgsConstructor;
  import lombok.Getter;
  import lombok.NoArgsConstructor;
  import lombok.Setter;
  
  // Entity 테이블과 바로 매핑 (없으면 자동 생성)
  @Entity
  @Getter
  @Setter
  @NoArgsConstructor
  @AllArgsConstructor
  public class Person {
  	// 행을 구분하는 PK 반드시 필요 (테이블 생성을 위해) 별도 구분자가 없을 경우 row 갯수 마다 자동 증가하는 ID를 키로 쓰면 됨	
  	@Id
  	@GeneratedValue(strategy = GenerationType.IDENTITY)
  	private Long id;
  	
  	private String name;
  	private int age;
  	
  	@OneToMany(mappedBy = "person") // 1대다 관계 사람 한 명에 여러 개 주문이 있을 수 있음
  	private List<Order> orders = new ArrayList<Order>();
  }
  ```

- 지연 로딩

- ![image-20250423113919591](API성능최적화_3일차.assets/image-20250423113919591.png)



- N+1문제
- ![image-20250423113932493](API성능최적화_3일차.assets/image-20250423113932493.png)
- ![image-20250423113954540](API성능최적화_3일차.assets/image-20250423113954540.png)
- ![image-20250423114055341](API성능최적화_3일차.assets/image-20250423114055341.png)
- ![image-20250423114102082](API성능최적화_3일차.assets/image-20250423114102082.png)

![스크린샷 2025-04-22 111558](API성능최적화_3일차.assets/스크린샷 2025-04-22 111558.png)

![스크린샷 2025-04-22 150917](API성능최적화_3일차.assets/스크린샷 2025-04-22 150917.png)

![스크린샷 2025-04-22 161613](API성능최적화_3일차.assets/스크린샷 2025-04-22 161613.png)

![스크린샷 2025-04-22 161859](API성능최적화_3일차.assets/스크린샷 2025-04-22 161859.png)

![스크린샷 2025-04-22 164735](API성능최적화_3일차.assets/스크린샷 2025-04-22 164735.png)

![스크린샷 2025-04-23 103548](API성능최적화_3일차.assets/스크린샷 2025-04-23 103548.png)

![스크린샷 2025-04-23 112535](API성능최적화_3일차.assets/스크린샷 2025-04-23 112535.png)

![스크린샷 2025-04-23 113916](API성능최적화_3일차.assets/스크린샷 2025-04-23 113916.png)

![스크린샷 2025-04-23 113931](API성능최적화_3일차.assets/스크린샷 2025-04-23 113931-1745382626696-7.png)

![스크린샷 2025-04-23 113947](API성능최적화_3일차.assets/스크린샷 2025-04-23 113947-1745382626696-8.png)

![스크린샷 2025-04-23 114050](API성능최적화_3일차.assets/스크린샷 2025-04-23 114050-1745382626696-9.png)

![스크린샷 2025-04-23 114059](API성능최적화_3일차.assets/스크린샷 2025-04-23 114059-1745382626696-10.png)

![스크린샷 2025-04-22 103155](API성능최적화_3일차.assets/스크린샷 2025-04-22 103155.png)

![스크린샷 2025-04-22 103546](API성능최적화_3일차.assets/스크린샷 2025-04-22 103546.png)

![스크린샷 2025-04-22 103812](API성능최적화_3일차.assets/스크린샷 2025-04-22 103812.png)

![스크린샷 2025-04-22 104900](API성능최적화_3일차.assets/스크린샷 2025-04-22 104900.png)





# 오후



## JPA 최적화 이어서

![image-20250423134511734](API성능최적화_3일차.assets/image-20250423134511734.png)





## API 응답 성능 개선

- ![image-20250423134531773](API성능최적화_3일차.assets/image-20250423134531773.png)



```properties
# 캐시 설정
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=500,expireAfterWrite=600s

# 비동기 처리 설정
spring.task.execution.pool.core-size=10
spring.task.execution.pool.max-size=20
spring.task.execution.pool.queue-capacity=500

# 응답 압축 설정
server.compression.enabled=true
server.compression.mime-types=text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json
server.compression.min-response-size=1KB
# 1KB 이상일 때만 압축
```



```java
package com.example.resttest.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

import org.springframework.cache.annotation.Cacheable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class UserController {
	
	@GetMapping
	@Cacheable(value = "homeCache", key = "'home'") // 빈번한 요청이 오는 화면, 데이터의 경우 캐시 추가(메모리에 넣어둠)
	@Async // CompletableFuture 타입으로 변경해서 보내야함, 비동기로 동시에 처리할 수 있도록 함
	public CompletableFuture<String> index(Model model) {
		return CompletableFuture.completedFuture("home");
	}
	
	// server.compression.min-response-size=1KB 1KB 이상일 때만 압축
	// f12 네트워크에서 수신 json 클릭 후 헤더에 gzip 압축 확인
    @GetMapping("/large-json") // 응답 압축 예제
    @ResponseBody
    public List<Map<String, Object>> getLargeJson() {
        List<Map<String, Object>> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            Map<String, Object> map = new HashMap<>();
            map.put("id", i);
            map.put("name", "User_" + i);
            map.put("description", "이건 매우 긴 설명입니다. 데이터를 반복해서 길게 만들어서 gzip 압축 테스트를 해보겠습니다. ".repeat(5));
            list.add(map);
        }
        return list;
    }    
    
    @GetMapping("/stream")
    @ResponseBody // 스트리밍 응답 예제, 청크단위 전송?, caffeine 캐시를 사용해야해서 의존성을 추가해야함
    public ResponseEntity<StreamingResponseBody> streamData() {

        StreamingResponseBody stream = outputStream -> {
            // 스트리밍 데이터 처리
            for (int i = 0; i < 1000; i++) {
                outputStream.write(("Data " + i + "\n").getBytes()); // 바로 바로 body에 담아서 전송
                outputStream.flush();  //바로 전송
                //Thread.sleep(100);
            }
        };

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.TEXT_PLAIN);

        return ResponseEntity.ok()
                .headers(headers)
                .body(stream);
    }
```



- ![image-20250423140403539](API성능최적화_3일차.assets/image-20250423140403539.png)

- ![image-20250423142902312](API성능최적화_3일차.assets/image-20250423142902312.png)
- ![image-20250423142912426](API성능최적화_3일차.assets/image-20250423142912426.png)
- ![image-20250423142923656](API성능최적화_3일차.assets/image-20250423142923656.png)
- ![image-20250423142935146](API성능최적화_3일차.assets/image-20250423142935146.png)
- ![image-20250423143005536](API성능최적화_3일차.assets/image-20250423143005536.png)
- ![image-20250423143039485](API성능최적화_3일차.assets/image-20250423143039485.png)



- ![image-20250423143234355](API성능최적화_3일차.assets/image-20250423143234355.png)
- ![image-20250423143241675](API성능최적화_3일차.assets/image-20250423143241675.png)
- ![image-20250423143253001](API성능최적화_3일차.assets/image-20250423143253001.png)
- ![image-20250423143601909](API성능최적화_3일차.assets/image-20250423143601909.png)



- ![image-20250423143555818](API성능최적화_3일차.assets/image-20250423143555818.png)
- ![image-20250423143617676](API성능최적화_3일차.assets/image-20250423143617676.png)
- ![image-20250423143625588](API성능최적화_3일차.assets/image-20250423143625588.png)
- ![image-20250423143633446](API성능최적화_3일차.assets/image-20250423143633446.png)
- ![image-20250423143639934](API성능최적화_3일차.assets/image-20250423143639934.png)

- ![image-20250423143654507](API성능최적화_3일차.assets/image-20250423143654507.png)
- ![image-20250423143704793](API성능최적화_3일차.assets/image-20250423143704793.png)
- ![image-20250423143711020](API성능최적화_3일차.assets/image-20250423143711020.png)

- ![image-20250423143721124](API성능최적화_3일차.assets/image-20250423143721124.png)



- ![image-20250423143741715](API성능최적화_3일차.assets/image-20250423143741715.png)
- ![image-20250423144105918](API성능최적화_3일차.assets/image-20250423144105918.png)



## 성능 테스트 (K6, jmeter)

- ![image-20250423144208224](API성능최적화_3일차.assets/image-20250423144208224.png)
- ![image-20250423144235407](API성능최적화_3일차.assets/image-20250423144235407.png)
- ![image-20250423144245019](API성능최적화_3일차.assets/image-20250423144245019.png)





### JMeter

- ![image-20250423144849787](API성능최적화_3일차.assets/image-20250423144849787.png)

- ![image-20250423144844192](API성능최적화_3일차.assets/image-20250423144844192.png)
- ![image-20250423145058205](API성능최적화_3일차.assets/image-20250423145058205.png)
- ![image-20250423145159555](API성능최적화_3일차.assets/image-20250423145159555.png)

- ![image-20250423145211509](API성능최적화_3일차.assets/image-20250423145211509.png)
- ![image-20250423145218317](API성능최적화_3일차.assets/image-20250423145218317.png)

- ![image-20250423151732579](API성능최적화_3일차.assets/image-20250423151732579.png)

- ![image-20250423151744071](API성능최적화_3일차.assets/image-20250423151744071.png)
- 



### Spring Actuator

- ![image-20250423153525272](API성능최적화_3일차.assets/image-20250423153525272.png)
- ![image-20250423153531141](API성능최적화_3일차.assets/image-20250423153531141.png)
- ![image-20250423153536756](API성능최적화_3일차.assets/image-20250423153536756.png)
- ![image-20250423153542154](API성능최적화_3일차.assets/image-20250423153542154.png)
- ![image-20250423153550381](API성능최적화_3일차.assets/image-20250423153550381.png)
- ![image-20250423153559379](API성능최적화_3일차.assets/image-20250423153559379.png)
- ![image-20250423153604551](API성능최적화_3일차.assets/image-20250423153604551.png)
- ![image-20250423153633516](API성능최적화_3일차.assets/image-20250423153633516.png)
- ![image-20250423153640003](API성능최적화_3일차.assets/image-20250423153640003.png)
- ![image-20250423153647108](API성능최적화_3일차.assets/image-20250423153647108.png)
- ![image-20250423153653297](API성능최적화_3일차.assets/image-20250423153653297.png)

- ![image-20250423153706332](API성능최적화_3일차.assets/image-20250423153706332.png)
- ![image-20250423153714589](API성능최적화_3일차.assets/image-20250423153714589.png)
- ![image-20250423153722094](API성능최적화_3일차.assets/image-20250423153722094.png)

- ```properties
  # spring actuator setting
  management.endpoints.web.exposure.include=*
  management.endpoint.health.show-details=always
  management.endpoint.metrics.enabled=true
  management.endpoint.prometheus.enabled=true
  management.metrics.export.prometheus.enabled=true
  management.endpoint.loggers.enabled=true
  management.endpoint.env.enabled=true
  management.endpoint.beans.enabled=true
  management.endpoint.threaddump.enabled=true
  management.endpoint.heapdump.enabled=true
  ```

```xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
```



### Prometheus, Grafana 대시보드

- ![image-20250423154806727](API성능최적화_3일차.assets/image-20250423154806727.png)
- ![image-20250423154813860](API성능최적화_3일차.assets/image-20250423154813860.png)
- ![image-20250423154905927](API성능최적화_3일차.assets/image-20250423154905927.png)
- ![image-20250423154913500](API성능최적화_3일차.assets/image-20250423154913500.png)
- ![image-20250423154920413](API성능최적화_3일차.assets/image-20250423154920413.png)

- cd C:\Users\GD\Downloads\prometheus-3.3.0.windows-amd64

- prometheus.exe --config.file=prometheus.yml

- 대부분의 성능이슈 sql 쿼리 (DB 문제)



- ![image-20250423163449432](API성능최적화_3일차.assets/image-20250423163449432.png)

- ![image-20250423163457941](API성능최적화_3일차.assets/image-20250423163457941.png)
- ![image-20250423163505038](API성능최적화_3일차.assets/image-20250423163505038.png)
- ![image-20250423163518008](API성능최적화_3일차.assets/image-20250423163518008.png)



- C:\Program Files\GrafanaLabs\grafana\bin
- ![image-20250423164332421](API성능최적화_3일차.assets/image-20250423164332421.png)



- [네이버 MYBOX](https://mybox.naver.com/#/share/url/detail?shareKey=I-XvckOSWeiKHjR8y8Z8UXI8wzt5_Sa3c7UdEn9-sLQE&resourceKey=aWxoYW5rfDM0NzI1OTY4NTk4Mzk0MDk3NDh8RHwxNjM1OTIzNQ)

- 작동X

- ![image-20250423172924370](API성능최적화_3일차.assets/image-20250423172924370.png)

- 정상작동

- ![image-20250423173130747](API성능최적화_3일차.assets/image-20250423173130747.png)



- fetch join + batchsize

- ```java
  package com.example.resttest.model;
  
  import java.util.List;
  
  import org.hibernate.annotations.BatchSize;
  
  import jakarta.persistence.Entity;
  import jakarta.persistence.FetchType;
  import jakarta.persistence.GeneratedValue;
  import jakarta.persistence.GenerationType;
  import jakarta.persistence.Id;
  import jakarta.persistence.JoinColumn;
  import jakarta.persistence.ManyToOne;
  import jakarta.persistence.Table;
  import lombok.AllArgsConstructor;
  import lombok.Getter;
  import lombok.NoArgsConstructor;
  import lombok.Setter;
  
  @Entity
  @Table(name="orders") // Order 테이블은 중복될 수 있어서 이름 바꿈
  @Getter
  @Setter
  @NoArgsConstructor
  @AllArgsConstructor
  public class Order {
  	// 행을 구분하는 PK 반드시 필요 (테이블 생성을 위해) 별도 구분자가 없을 경우 row 갯수 마다 자동 증가하는 ID를 키로 쓰면 됨	
  	@Id
  	@GeneratedValue(strategy = GenerationType.IDENTITY)
  	private Long id;
  	
  	private String productName;
  	private double price;
  	
  	@ManyToOne(fetch = FetchType.LAZY) // 여러 주문은 한 사람에게 적용 될 수 있음
  	@BatchSize(size = 10)
  	@JoinColumn(name = "person_id")
  	private Person person;
  }
  ```

- ```sql
  select * from orders;
  select * from person where id in (1,2,3,4,5...10);
  select * from person where id in (11,12,13,14,15...20);
  ```



- ```java
  package com.example.resttest.repository;
  
  import java.util.List;
  import java.util.Optional;
  
  import org.springframework.data.jpa.repository.JpaRepository;
  import org.springframework.data.jpa.repository.Query;
  import org.springframework.data.repository.query.Param;
  
  import com.example.resttest.model.Order;
  //fetch join 여러번 반복문을 한번에 처리해버림 (속도 향상)
  public interface OrderRepository extends JpaRepository<Order, Long> {
      @Query("SELECT o FROM Order o JOIN FETCH o.person WHERE  = :orderId")
      Optional<Order> findOrderWithPerson(@Param("orderId") Long orderId);
  
      List<Order> findByPersonId(Long personId);
      
      @Query("SELECT o FROM Order o JOIN FETCH o.person")
      List<Order> findAllWithPerson();
      
      @Query("SELECT o FROM Order o JOIN FETCH o.person p WHERE  = :personId")
      List<Order> findByPersonIdWithPerson(@Param("personId") Long personId);
  }
  ```

- 